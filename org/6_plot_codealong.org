#+TITLE:  Base R plot function - part 1
#+AUTHOR: Marcus Birkenkrahe
#+Subtitle: Introduction to Data Visualization
#+STARTUP: hideblocks overview indent inlineimages
#+PROPERTY: header-args:R :exports both :results output :session *R*
* The ~plot~ function

- ~plot(x,y,...)~ is a /generic/ function - it adapts to its arguments:
  e.g.

  | Plot type   | ~x~       | ~y~       |
  |-------------+---------+---------|
  | Scatterplot | ~numeric~ | ~numeric~ |
  | Boxplot     | ~factor~  | ~numeric~ |
  | Bar chart   | ~factor~  | ~NA~      |
  | Mosaic plot | ~factor~  | ~factor~  |

- For an overview of the different methods available, use ~methods~.

  #+name: methods
  #+begin_src R
    methods(plot)
  #+end_src

  #+RESULTS: methods
  :  [1] plot.acf*           plot.data.frame*    plot.decomposed.ts* plot.default        plot.dendrogram*   
  :  [6] plot.density*       plot.ecdf           plot.factor*        plot.formula*       plot.function      
  : [11] plot.hclust*        plot.histogram*     plot.HoltWinters*   plot.isoreg*        plot.lm*           
  : [16] plot.medpolish*     plot.mlm*           plot.ppr*           plot.prcomp*        plot.princomp*     
  : [21] plot.profile.nls*   plot.raster*        plot.spec*          plot.stepfun        plot.stl*          
  : [26] plot.table*         plot.ts             plot.tskernel*      plot.TukeyHSD*     
  : see '?methods' for accessing help and source code

- In the extended example, we already applied ~plot~ to a data frame, a
  numeric vector, a factor, and a pair of numeric variables, leading
  to an array of scatterplots, a bar chart, and a scatterplot.

* Bar chart with ~plot~

When only one categorical variable is given, ~plot~ generates a bar
chart with one bar per factor level.

#+begin_src R
  x <- c(1,2,2,3,3,3)  # (numeric) vector with three values
  x_f <- factor(x)  # (nominal) factor with three levels
  x_f
#+end_src

#+RESULTS:
: [1] 1 2 2 3 3 3
: Levels: 1 2 3

Plot the factor vector:
#+begin_src R :results graphics file :file 4_barchart.png :exports both
  plot(x_f)
#+end_src

#+RESULTS:
[[file:4_barchart.png]]

* Line plot with ~plot~

When a time series is given like the data set ~Nile~, ~plot~ generates a
line plot.

#+begin_src R
  class(Nile)
  str(Nile)
#+end_src

#+RESULTS:
: [1] "ts"
:  Time-Series [1:100] from 1871 to 1970: 1120 1160 963 1210 1160 1160 813 1230 1370 1140 ...

#+begin_src R :results graphics file :file 4_lineplot.png :exports both
  plot(Nile,type="b")
  grid()
#+end_src

#+RESULTS:
[[file:4_lineplot.png]]

* Box plots with ~plot~

- We used the ~boxplot~ function to create a boxplot summary of heating
  gas consumption before and after installation of insulation in
  =MASS::whiteside=:

- The same result with ~plot~ instead of =boxplot=: use the =Insul= and the
  =Gas= variable of the =whiteside= dataset to do this:

  #+begin_src R
    library(MASS)
    data(whiteside)
    str(whiteside)
    whiteside$Insul -> insul
    whiteside$Gas -> gas
  #+end_src

  #+RESULTS:
  : 'data.frame':	56 obs. of  3 variables:
  :  $ Insul: Factor w/ 2 levels "Before","After": 1 1 1 1 1 1 1 1 1 1 ...
  :  $ Temp : num  -0.8 -0.7 0.4 2.5 2.9 3.2 3.6 3.9 4.2 4.3 ...
  :  $ Gas  : num  7.2 6.9 6.4 6 5.8 5.8 5.6 4.7 5.8 5.2 ...

  #+name: whitesideplot1
  #+begin_src R :results graphics file :file 4_whiteside1.png
    # plot(gas , insul)   # not what we want
    plot(insul, gas)  # or with formula: plot(gas ~ insul)
  #+end_src

  #+RESULTS: whitesideplot1
  [[file:4_whiteside1.png]]

- Customization is simple:
  1) "Insulation" for x
  2) "Gas consumption" for y
  3) "Whiteside data set" for the title
  #+name: whitesideplot2
  #+begin_src R :results graphics file :file 4_whiteside2.png :exports both
    plot(x=insul, y=gas,   # data
         xlab="Insulation",
         ylab="Gas consumption [cubic feet/1000] ",
         main="Whiteside data set")
  #+end_src

  #+RESULTS: whitesideplot2
  [[file:4_whiteside2.png]]

* Decision tree models with ~plot~

- Many modeling functions in R return a object that can be plotted

- You can store these objects and work with them during analysis

- Example: /decision tree models/ from the ~whiteside~ data frame using
  the ~rpart~ package.

- This model predicts the average value of the dependent variable,
  ~Gas~, from the values of the other variables, ~Insul~ and ~Temp~.

- Build the model: the formula only has two parts. The period operator
  ~.~ stands for "all other variables" - it's common in other graphics
  packages, too.
  #+name: rpart1
  #+begin_src R
    library(MASS)
    library(rpart)
    # model Gas vs all other columns
    rpart(Gas ~ ., data = whiteside) -> rpartModel 
    class(rpartModel)
  #+end_src

  #+RESULTS: rpart1
  : [1] "rpart"

- Plot the model and add generic text using ~text~ for ~rpart~ models:

  #+begin_src R :results graphics file :file 4_rpart.png :exports both
    plot(rpartModel)
    text(rpartModel)
  #+end_src

  #+RESULTS:
  [[file:4_rpart.png]]

- What methods are available for ~rpart~ and ~text~?
  #+begin_src R
    methods(class="rpart")
    methods(text)
  #+end_src

  #+RESULTS:
  :  [1] labels      meanvar     model.frame plot        post        predict     print       prune       residuals  
  : [10] summary     text       
  : see '?methods' for accessing help and source code
  : [1] text.default  text.formula* text.rpart*  
  : see '?methods' for accessing help and source code

- Let's try ~summary~, which generated Tukey's summary for data frames:
  #+begin_src R
    summary(rpartModel)
  #+end_src

  #+RESULTS:
  #+begin_example
  Call:
  rpart(formula = Gas ~ ., data = whiteside)
    n= 56 

            CP nsplit rel error    xerror       xstd
  1 0.30233737      0 1.0000000 1.0335777 0.22255362
  2 0.15906314      2 0.3953253 0.8899163 0.15104463
  3 0.03529048      3 0.2362621 0.6442837 0.09494637
  4 0.01000000      4 0.2009716 0.5870547 0.09558054

  Variable importance
   Temp Insul 
     67    33 

  Node number 1: 56 observations,    complexity param=0.3023374
    mean=4.071429, MSE=1.339541 
    left son=2 (30 obs) right son=3 (26 obs)
    Primary splits:
        Insul splits as  RL,       improve=0.2979115, (0 missing)
        Temp  < 7.05 to the right, improve=0.2905559, (0 missing)
    Surrogate splits:
        Temp < 5.35 to the left,  agree=0.679, adj=0.308, (0 split)

  Node number 2: 30 observations,    complexity param=0.1590631
    mean=3.483333, MSE=0.6287222 
    left son=4 (8 obs) right son=5 (22 obs)
    Primary splits:
        Temp < 5.75 to the right, improve=0.6326062, (0 missing)

  Node number 3: 26 observations,    complexity param=0.3023374
    mean=4.75, MSE=1.300192 
    left son=6 (16 obs) right son=7 (10 obs)
    Primary splits:
        Temp < 4.85 to the right, improve=0.6807166, (0 missing)

  Node number 4: 8 observations
    mean=2.4375, MSE=0.3723437 

  Node number 5: 22 observations,    complexity param=0.03529048
    mean=3.863636, MSE=0.1795868 
    left son=10 (15 obs) right son=11 (7 obs)
    Primary splits:
        Temp < 2.4  to the right, improve=0.6700458, (0 missing)

  Node number 6: 16 observations
    mean=4.00625, MSE=0.3630859 

  Node number 7: 10 observations
    mean=5.94, MSE=0.4984 

  Node number 10: 15 observations
    mean=3.626667, MSE=0.04595556 

  Node number 11: 7 observations
    mean=4.371429, MSE=0.0877551
  #+end_example

* Model-based recursive partitioning with ~plot~

- MOB models have tree-based structures like decision tree models

- Each terminal node contains a linear regression model that generates
  predictions from other covariates (independent variables)

- The code to generate the model looks very similar to ~rpart~: the
  formula has three parts - ~Gas~ is predicted, ~Temp~ is the covariate to
  predict, and ~Insul~ is the partitioning variable used to build the
  tree.
  #+name: MOB1
  #+begin_src R
    library(partykit)  # this will load 3 other packages
    lmtree(Gas ~ Temp | Insul, data=whiteside) -> MOBmodel
    class(MOBmodel)
  #+end_src

  #+RESULTS: MOB1
  : [1] "lmtree"     "modelparty" "party"

- In the plot, all records are assigned to one of the nodes, and a
  separate linear regression model that predicts ~Gas~ from ~Temp~ is
  built for each node.
  #+name: MOB2
  #+begin_src R :results graphics file :file ../img/4_mob.png :exports both
    plot(MOBmodel)
  #+end_src

  #+RESULTS: MOB2
  [[file:../img/4_mob.png]]

- What methods are available for ~lmtree~ ?
  #+begin_src R
    methods(class="lmtree")
  #+end_src

  #+RESULTS:
  : [1] plot    predict print   prune  
  : see '?methods' for accessing help and source code

* What does this mean?

1) Enormous graphics flexibility even within the base R graphics
   package. Regrettably, there seems to be a "package envy" phenomenon
   within the R community, fostered by RStudio's aggressive marketing

2) You can define your own object classes and construct methods for
   generic functions like ~plot~ or ~summary~ that make them generate
   specialized results for our object classes.

3) ~methods~ reveals the "S3 Object" character of R, dependent on the
   packages loaded into your R session. S is the language that came
   before R. In OOP, objects have /methods/ and /attributes/.

   #+begin_src R
     attributes(mtcars)
   #+end_src

   For an example of the information stored in this model, run
   ~plot(lmod)~ in the R console - this will produce several plots at
   once (click on the graph to move to the next one).

* Optional parameters for base graphics

- There are 72 optional base graphics parameters set by the ~par~
  function

- Check out the help for ~par~ right now (*on the R console*).

- ~par~ can also be called (like ~options~ and other system
  functions). Can you list all the parameters in =par=?

  #+begin_src R :results none
    attribtutes(par())   # par() is a list while `par` is a function
    names(par())
    str(par())
  #+end_src

- As you can read in ~help(par)~, some of these parameters are read-only
  (i.e. their values are fixed), e.g. =cin=, the size of characters in
  inches, or the device dimensions, =din=.

* Important parameters for ~plot~ customization

- ~mfrow~ is a 2-dim vector that sets up an array of plots.

- Normally, =mfrow= is limited to 6 plots per page but there are
  exceptions, e.g. the pair plot:
  #+begin_src R :file panel.png :session *R* :results output graphics file
  plot(mtcars)
  #+end_src

- Make two plots with two panels, both line plots, to plot 100 and
  1000 random numbers: =rnorm(100)= generates 100 normally distributed
  pseudo-random numbers.
  #+name: mfrow
  #+begin_src R :session *R* :results graphics file :file 4_mfrow.png :exports both
    par(mfrow=c(2,1))
    plot(rnorm(100),type="l")
    title("100 random numbers")
    plot(rnorm(1000),type="l")
    title("1000 random numbers")
  #+end_src

  #+RESULTS: mfrow
  [[file:4_mfrow.png]]

- Now put the scatterplot versions of these plots on one page, on top
  of one another.
  #+begin_src R :session *R* :results graphics file :file 4_mfrow1.png :exports both
    par(mfrow=c(2,1))
    plot(rnorm(100))  # scatterplot is the default
    title("100 random numbers")
    plot(rnorm(1000))
    title("1000 random numbers")
  #+end_src

  #+RESULTS:
  [[file:4_mfrow1.png]]

- Several parameters come in groups:

  1) The ~cex~ family scales text and symbols in relation to one
     another, e.g. ~cex.main~ scales the main plot title relative to ~cex~
     #+name: cex
     #+begin_src R :session *R* :results graphics file :file 4_cex.png :exports both
       plot(rnorm(100),
            main="Double the size",
            cex=2,  # scale the points
            cex.main=2,
            pch=16)   # scale the title characters
     #+end_src

     #+RESULTS: cex
     [[file:4_cex.png]]

   2) The ~col~ family specifies colors for points, lines, text. To see
      the complete set of colors, enter ~colors()~.

      #+begin_src R
        length(colors())
      #+end_src

      #+RESULTS:
      : [1] 657

     #+begin_src R :session *R* :results graphics file :file 4_col.png :exports both
       plot(rnorm(100),
            main="Color me impressed",
            col="purple",
            pch=16,
            cex=2, cex.main=2,
            col.main="red",
            col.axis="blue"
            )
     #+end_src

     #+RESULTS:
     [[file:4_col.png]]

  3) The ~font~ family specifies font types (plain = 1, bold = 2, italic
     = 3, bold italic = 4).
     #+name: font
     #+begin_src R :session *R* :results graphics file :file ../img/4_font.png :exports both
       plot(rnorm(100),
            main="Fountain of font",
            font.main=4,
            cex.main=2,
            font.lab=2)
     #+end_src

     #+RESULTS: font
     [[file:../img/4_font.png]]

* Other parameters

- ~adj~ specifies justification of the text (0=left,1=right, center=0.5)

  #+begin_src R :session *R* :results graphics file :file 4_adj.png :exports both
    plot(rnorm(100), type="n")
    text(x=40,y=0,labels="Right-justified text", adj=1, font=3)
    text(x=40,y=-1,labels="Left-justified text", adj=0, font=3)
    text(x=40,y=1.5,labels="Centered text", adj=0.5, font=3)        
  #+end_src

  #+RESULTS:
  [[file:4_adj.png]]

- ~lty~ and ~lwd~ specify line type and line width.
  #+name: linewidth
  #+begin_src R :session *R* :results graphics file :file 4_lty.png :exports both

  #+end_src

  #+name: linewidth
  #+begin_src R :session *R* :results graphics file :file 4_lwd.png :exports both

  #+end_src

- How can you see current values of these parameters? Remember how to
  do this with ~options()~? What type of R object is ~par()~?

  #+begin_src R

  #+end_src

* Multiple plots and passing parameters

- The ~ask~ parameter is a /logical/ flag (the default value is ~FALSE~)
  that specifies whether the graphics system should wait for a user
  response before displaying the next plot.

- How can I confirm that ~ask~ is ~logical~, and see its value?

  #+begin_src R
  
  #+end_src

* Adding points and lines to a scatterplot

Our target:
https:github.com/birkenkrahe/dviz/blob/main/img/4_details.png

* Starting ~plot~ without bells and whistles

- Starting point is calories vs. sugars from the ~UScereal~ data frame
  #+name: cerealplot
  #+begin_src R :results graphics file :file 4_cereal.png :exports both

  #+end_src

* Adding axis labels ~xlab~, ~ylab~, and ~type~

- The next block invokes ~plot~ again, but with three optional
  arguments:

  1) ~xlab~: a ~character~ string for the x-axis label
  2) ~ylab~: a ~character~ string for the y-axis label
  3) ~type = "n"~: plot is constructed but /not displayed/

  #+name: cerealplot_nothing
  #+begin_src R :results graphics file :file 4_cereal1.png :exports both

  #+end_src

* Highlighting outliers with ~points~

- ~points~ behaves much like ~plot~. It adds points to an existing plot.

- Is ~points~ a /generic/ R function?
  #+begin_src R

  #+end_src

- The function takes the coordinate vectors of points to plot

- We want to distinguish outliers and non-outliers. Our definition for
  outliers: cereals with more than 300 calories per serving.

- To extract the subvectors, we define an index vector - it contains
  only the index value of the outliers.
  #+begin_src R

  #+end_src

- We plot the non-outliers with one type of point (~pch=16~), the
  outliers with another (~pch=18~) and twice as large (~cex=2~).

- Now we're ready to enhance our basic plot.
  #+name: cerealplot_outliers
  #+begin_src R :results graphics file :file 4_cereal2.png :exports both :noweb yes
    <<cerealplot_nothing>>

  #+end_src

* Add reference lines with ~abline~

- The final four lines of code add two reference lines using linear
  regression models.

- Now we're ready to enhance our basic plot.
  #+name: cerealplot_trends
  #+begin_src R :results graphics file :file 4_cereal3.png :exports both :noweb yes
    <<cerealplot_outliers>>

  #+end_src

- Do you think ~abline~ is a generic function?
  #+begin_src R
    
  #+end_src

* Customization with vectors

- Consider the following code to plot ~whiteside~ variables
  #+begin_src R :results graphics file :file 4_pch.png :exports both

  #+end_src

- ~c(6,16)~ defines a vector of the same length as ~Insul~ but uses ~pch=6~
  when ~Insul = "Before"~, and ~pch=16~ when ~Insul="After"~:
  #+begin_src R

  #+end_src

- The ~pch~ parameter will accept a vector argument of the same length
  as the ~x~- and ~y~-vectors used to create the scatterplot

- Point sizes (~cex~) and colors (~col~) can also be specifed this way

* Adding text to a plot

- The ~text~ function works similarly to the other customizing functions

- ~text~ specifies: x- and y-position of the text, and the text itself.

- Left-right alignment is specified by ~adj~ whose default is centered
  (~0.5~). To justify right, we need to set it to ~adj=1~

- The code block is growing, so let's look at the ~text~ addition alone:
  #+begin_example R

  #+end_example

  1) We define a text label. The ~paste~ function concatenates vectors
     after converting to ~character~. Here, it concatenates a value of
     the data frame and the character ~-->~
     #+begin_src R

     #+end_src

  2) Let's take the expression ~rownames(UScereal)[index]~ apart:
     You've seen this indexing structure before, in ~par()$lty~.

     ~rownames~ extracts the names of rows of a data frame:
     #+begin_src R

     #+end_src

     ~index~ was defined earlier as a subset of ~UScereal$calories~ values
     greater than the outlier cutoff value 300: ~index <- which(y > 300)~

     Hence, ~rownames(UScereal)[index]~ extracts the cereal names
     associated with the outlying values and puts them in the text box:
     #+begin_src R

     #+end_src

  3) Inside the ~text~ function, we have three sections:
     - coordinates x and y for the text field.
     - labels, namely the text to be printed in the plot
     - formatting parameters like text justification, font type etc.

- The complete R code block for printout looks like this now:
  #+name: cerealplot_text
  #+begin_src R :results graphics file :file 4_cereals4.png :exports both :noweb yes
    <<cerealplot_trends>>

  #+end_src

* Adding a legend to a plot

- The ~legend~ function adds a boxed explanatory text display

- It can be used like the ~text~ function: box location and text

- It has many more optional parameters (check out ~help(legend)~).
 
- Let's look at the code fragment for the legend only:
  #+begin_example R

  #+end_example

- Our final R code block:
  #+begin_src R :results graphics file :file 4_cereals5.png :exports both :noweb yes
    <<cerealplot_text>>

  #+end_src

* Customizing axes

- You already know about labelling axes with ~xlab~ and ~ylab~

- In addition, the limits of the axes can be set with ~xlim~ and ~ylim~

- The ~par~ function offers additional parameters like ~las~ and ~side~

- ~las~ specifies the orientation of the axis labels:
  1) ~las=0~ : labels are displayed axis-parallel (default)
  2) ~las=1~ : labels are always horizontal
  3) ~las=2~ : labels are always perpendicular to the axis
  4) ~las=3~ : labels are always vertical

- To aid readability, you may also have to adjust ~cex.lab~

- Example:
  #+begin_src R :results graphics file :file ../img/4_las.png :exports both
    par(las=0, mfrow=c(2,2))   # labels are axis parallel
    plot(Nile, main="las=0")  
    par(las=1)                 # labels horizontal
    plot(Nile, main="las=1")
    par(las=2)                 # labels axis perpendicular
    plot(Nile, main="las=2")
    par(las=3)                 # labels vertical
    plot(Nile, main="las=3")
  #+end_src

  #+RESULTS:
  [[file:../img/4_las.png]]

* Specifying your own axes

- You can specify your own axes in two steps:
  1. execute the base graphics function with ~axes = FALSE~
  2. Use the ~axis~ function to specify your own axes

- The default axes are now suppressed and you need to set:
  1) ~side = 1~ : creates (default) lower x-axis below the plot
  2) ~side = 2~ : creates (default) y-axis left of the plot
  3) ~side = 3~ : creates upper x-axis above the plot
  4) ~side = 4~ : creates a y-axis right of the plot

- Example: boxplot of the range of ~sugars~ values for each of the three
  levels of ~shelf~ value in the ~UScereal~ dataframe:
  1) ~shelf = 1~ is at the floor level
  2) ~shelf = 2~ is the middle shelf (kid-eye-level)
  3) ~shelf = 3~ is on the top shelf (adult-eye-level)

- Box plot without axes: The ~varwidth~ parameter creates a boxplot of
  variable width so that the width of each individual boxplot reflects
  the number of different cereals on each shelf.
  #+begin_src R :results graphics file :file ../img/4_axis1.png :exports both
    boxplot(
      sugars ~ shelf,
      data = UScereal,
      axes = FALSE,  # this removes the default axes
      xlab = "Shelf",
      ylab = "Grams of sugar per serving",
      varwidth = TRUE)
  #+end_src

  #+RESULTS:
  [[file:../img/4_axis1.png]]
  
- Box plot with axis specified using ~axis~: 
  #+begin_src R :results graphics file :file ../img/4_axis2.png :exports both
    boxplot(
      sugars ~ shelf,
      data = UScereal,
      axes = FALSE,  # this removes the default axes
      xlab = "Shelf",
      ylab = "Grams of sugar per serving",
      varwidth = TRUE)
    axis(                # construct bottom axis (shelf value)
      side = 1,          # lower axis below plot
      at = c(1,2,3),     # tick marks
      labels = c(1,2,3)) # number labels
    yRange <- seq(0, max(UScereal$sugars), by=5)
      axis(             # construct y-axis
      side = 2,         # y axis left of plot
      at = yRange,      # tick marks
      labels = yRange)  # number labels
    axis(               # construct top axis (shelf location)
      side = 3,         # upper axis above plot
      at = c(1,2,3),    # tick marks
      labels = c("Floor", "Mid", "Top"))  # text labels
  #+end_src

  #+RESULTS:
  [[file:../img/4_axis2.png]]
  

